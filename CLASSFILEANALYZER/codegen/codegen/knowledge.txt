C3:
def visitBinExpr(self, ctx, o):
    op = ctx.op
    e1_code, e1_type = self.visit(ctx.e1, o)
    e2_code, e2_type = self.visit(ctx.e2, o)

    if op in ['+', '-', '*', '/']:
        code = e1_code + e2_code
        if op == '+':
            code += self.emit.emitADDOP('+', IntType(), o.frame)
        elif op == '-':
            code += self.emit.emitADDOP('-', IntType(), o.frame)
        elif op == '*':
            code += self.emit.emitMULOP('*', IntType(), o.frame)
        elif op == '/':
            code += self.emit.emitMULOP('/', IntType(), o.frame)
        return code, IntType()
    
    elif op in ['+.', '-.', '*.', '/.']:
        code = e1_code + e2_code
        if op == '+.':
            code += self.emit.emitADDOP('+', FloatType(), o.frame)
        elif op == '-.':
            code += self.emit.emitADDOP('-', FloatType(), o.frame)
        elif op == '*.':
            code += self.emit.emitMULOP('*', FloatType(), o.frame)
        elif op == '/.':
            code += self.emit.emitMULOP('/', FloatType(), o.frame)
        return code, FloatType()
C4:
    def visitBinExpr(self, ctx, o):
        e1c, e1t = self.visit(ctx.e1, o)
        e2c, e2t = self.visit(ctx.e2, o)
        
        if type(e1t) is type(e2t):
            rt = e1t
        elif type(e1t) is IntType and type (e2t) is FloatType:
            e1c += self.emit.emitI2F(o.frame)
            rt = FloatType()
        else:
            e2c += self.emit.emitI2F(o.frame)
            rt = FloatType()
            
        if ctx.op in ['+', '-']:
            opc = self.emit.emitADDOP(ctx.op, rt, o.frame)
            
        elif ctx.op == '*':
            opc = self.emit.emitMULOP(ctx.op, rt, o.frame)
            
        elif ctx.op == '/':
            e1c += self.emit.emit.F2I(o.frame)
            e2c += self.emit.emit.F2I(o.frame)
            rt = FloatType()
            opc = self.emit.emitMULOP(ctx.op, rt, o.frame)
        
        else:
            opc = self.emit.emitRELOP(ctx.op, rt, o.frame)
            rt = BoolType()

        return e1c + e2c + opc, rt

C5:
    def visitId(self, ctx, o):
        sym = next(filter(lambda x: x.name == ctx.name, o.sym), False) # Find symbol in o.sym that has name == ctx.name
        if type(sym.value) is Index:
            code = self.emit.emitREADVAR(sym.name, sym.mtype, sym.value.value, o.frame)
        else:
            code = self.emit.emitGETSTATIC(sym.value.value + "." + sym.name, sym.mtype, o.frame)
            # sym.value.value + "." + sym.name: tim ten lop trong cua static, tạo ra tên đầy đủ của biến toàn cục, vì:

            # sym.value.value là tên lớp chứa biến

            #sym.name là tên của biến


        
        return code, sym.mtype

C6:
    def visitId(self, ctx, o):
        sym = next(filter(lambda x: x.name == ctx.name, o.sym), False) # Find symbol in o.sym that has name == ctx.name
        if o.isLeft:
            if type(sym.value) is Index:
                code = self.emit.emitWRITEVAR(sym.name, sym.mtype, sym.value.value, o.frame)
            else:
                code = self.emit.emitPUTSTATIC(sym.value.value + "." + sym.name, sym.mtype, o.frame)
        else:
            if type(sym.value) is Index:
                code = self.emit.emitREADVAR(sym.name, sym.mtype, sym.value.value, o.frame)
            else:
                code = self.emit.emitGETSTATIC(sym.value.value + "." + sym.name, sym.mtype, o.frame)
        
        return code, sym.mtype
